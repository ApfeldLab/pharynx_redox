<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>Profile Estimation Experiments - the Rossler Equations</title>
      <meta name="generator" content="MATLAB 7.1">
      <meta name="date" content="2006-08-11">
      <meta name="m-file" content="RosslerEx"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows.  On Gecko-based browsers, the shrink-to-fit doesn't work. */ 
p,h1,h2,div.content div {
  /* for MATLAB's browser */
  width: 600px;
  /* for Mozilla, but the "width" tag overrides it anyway */
  max-width: 600px;
  /* for IE */
  width:expression(document.body.clientWidth > 620 ? "600px": "auto" );
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>Profile Estimation Experiments - the Rossler Equations</h1>
         <introduction>
            <p>This page provides code to run profiled parameter estimation on data generated by the Rossler equations. It follows the same
               format as FhNEx.html and has commentary has therefore been kept to a minimum.
            </p>
            <p>The Rossler equations are given by</p>
            <p><img vspace="5" hspace="5" src="RosslerEx_eq1450.png"> </p>
            <p><img vspace="5" hspace="5" src="RosslerEx_eq1955.png"> </p>
            <p><img vspace="5" hspace="5" src="RosslerEx_eq3343.png"> </p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">RHS Functions</a></li>
               <li><a href="#2">Various parameters</a></li>
               <li><a href="#3">Observation times</a></li>
               <li><a href="#4">Create trajectories</a></li>
               <li><a href="#5">Set up observations</a></li>
               <li><a href="#6">Fitting parameters</a></li>
               <li><a href="#7">Profiling optimisation control</a></li>
               <li><a href="#8">Setting up functional data objects</a></li>
               <li><a href="#9">Smooth the data</a></li>
               <li><a href="#10">Re-smoothing with model-based penalty</a></li>
               <li><a href="#11">Perform the Profiled Estimation</a></li>
               <li><a href="#12">Plot Smooth with Profile-Estimated Parameters</a></li>
               <li><a href="#13">Comparison with Smooth Using True Parameters</a></li>
               <li><a href="#14">Squared Error Performance</a></li>
               <li><a href="#15">Calculate Sample Information and Variance-Covariance Matrices</a></li>
            </ul>
         </div>
         <h2>RHS Functions<a name="1"></a></h2><pre class="codeinput">odefn       = @rossfunode;    <span class="comment">% Function for ODE solver</span>

fn.fn       = @rossfun;       <span class="comment">% RHS function</span>
fn.dfdx     = @rossdfdx;      <span class="comment">% Derivative wrt inputs</span>
fn.dfdp     = @rossdfdp;      <span class="comment">% Derviative wrt parameters</span>

fn.d2fdx2   = @rossd2fdx2;    <span class="comment">% Hessian wrt inputs</span>
fn.d2fdxdp  = @rossd2fdxdp;   <span class="comment">% Hessian wrt inputs and parameters</span>
fn.d2fdp2   = @rossd2fdp2;    <span class="comment">% Hessian wrt parameters.</span>

fn.d3fdx3   = @rossd3fdx3;    <span class="comment">% Third derivative wrt inputs.</span>
fn.d3fdx2dp = @rossd3fdx2dp;  <span class="comment">% Third derivative wrt intputs, inputs and pars.</span>
fn.d3fdxdp2 = @rossd3fdxdp2;  <span class="comment">% Third derivative wrt inputs, pars and pars.</span>
</pre><h2>Various parameters<a name="2"></a></h2><pre class="codeinput">y0 = [1.13293; -1.74953; 0.02207];       <span class="comment">% Initial conditions</span>

pars = [0.2; 0.2; 3];           <span class="comment">% Parameters</span>

sigma = 0.5;                    <span class="comment">% Noise Level</span>

jitter = 0.2;                                    <span class="comment">% Perturbation for starting</span>
startpars = pars + jitter*randn(length(pars),1); <span class="comment">% parameter estimates</span>
disp([<span class="string">'Initial par. values: '</span>,num2str(startpars')])
</pre><pre class="codeoutput">Initial par. values: -0.39343     0.59033      2.6905
</pre><h2>Observation times<a name="3"></a></h2><pre class="codeinput">tspan = 0:0.05:20;    <span class="comment">% Observation times</span>

obs_pts{1} = 1:length(tspan);      <span class="comment">% Which components are observed at</span>
obs_pts{2} = 1:length(tspan);      <span class="comment">% which observation times.</span>
obs_pts{3} = 1:length(tspan);


tfine = 0:0.05:20;    <span class="comment">% Times to plot solutions</span>
</pre><h2>Create trajectories<a name="4"></a></h2><pre class="codeinput">odeopts = odeset(<span class="string">'RelTol'</span>,1e-13);
[full_time,full_path] = ode45(odefn,tspan,y0,odeopts,pars);
[plot_time,plot_path] = ode45(odefn,tfine,y0,odeopts,pars);
</pre><h2>Set up observations<a name="5"></a></h2><pre class="codeinput">Tcell = cell(1,size(full_path,2));
path = Tcell;

<span class="keyword">for</span> i = 1:length(obs_pts)
    Tcell{i} = full_time(obs_pts{i});
    path{i} = full_path(obs_pts{i},i);
<span class="keyword">end</span>

<span class="comment">% add noise</span>

Ycell = path;
<span class="keyword">for</span> i = 1:length(path)
    Ycell{i} = path{i} + sigma*randn(size(path{i}));
<span class="keyword">end</span>

<span class="comment">% and set wts</span>

wts = [];

<span class="keyword">if</span> isempty(wts)                             <span class="comment">% estimate wts if not given</span>
    <span class="keyword">for</span> i = 1:length(Ycell)
        <span class="keyword">if</span> ~isempty(Ycell{i})
            wts(i) = 1./sqrt(var(Ycell{i}));
        <span class="keyword">else</span>
            wts(i) = 1;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2>Fitting parameters<a name="6"></a></h2><pre class="codeinput">lambda  = 1e4;   <span class="comment">% Smoothing for model-based penalty</span>
lambda  = lambda*wts;

lambda0 = 1;     <span class="comment">% Smoothing for 1st-derivative penalty</span>

nknots = 401;    <span class="comment">% Number of knots to use.</span>
nquad  = 5;      <span class="comment">% No. between-knots quadrature points.</span>
norder = 3;      <span class="comment">% Order of B-spline approximation</span>
</pre><h2>Profiling optimisation control<a name="7"></a></h2><pre class="codeinput">lsopts_out = optimset(<span class="string">'DerivativeCheck'</span>,<span class="string">'off'</span>,<span class="string">'Jacobian'</span>,<span class="string">'on'</span>,<span class="keyword">...</span>
    <span class="string">'Display'</span>,<span class="string">'iter'</span>,<span class="string">'MaxIter'</span>,1000,<span class="string">'TolFun'</span>,1e-8,<span class="string">'TolX'</span>,1e-10);

<span class="comment">% Other observed optimiation control</span>
lsopts_other = optimset(<span class="string">'DerivativeCheck'</span>,<span class="string">'off'</span>,<span class="string">'Jacobian'</span>,<span class="string">'on'</span>,<span class="keyword">...</span>
    <span class="string">'Display'</span>,<span class="string">'iter'</span>,<span class="string">'MaxIter'</span>,1000,<span class="string">'TolFun'</span>,1e-14,<span class="string">'TolX'</span>,1e-14,<span class="keyword">...</span>
    <span class="string">'JacobMult'</span>,@SparseJMfun);

<span class="comment">% Optimiation control within profiling</span>
lsopts_in = optimset(<span class="string">'DerivativeCheck'</span>,<span class="string">'off'</span>,<span class="string">'Jacobian'</span>,<span class="string">'on'</span>,<span class="keyword">...</span>
    <span class="string">'Display'</span>,<span class="string">'off'</span>,<span class="string">'MaxIter'</span>,1000,<span class="string">'TolFun'</span>,1e-14,<span class="string">'TolX'</span>,1e-14,<span class="keyword">...</span>
    <span class="string">'JacobMult'</span>,@SparseJMfun);
</pre><h2>Setting up functional data objects<a name="8"></a></h2><pre class="codeinput"><span class="comment">% set up knots</span>

range = [min(full_time),max(full_time)];  <span class="comment">% range of observations</span>

knots_cell = cell(size(path));            <span class="comment">% knots for each basis</span>
knots_cell(:) = {linspace(range(1),range(2),nknots)};

<span class="comment">% set up bases</span>

basis_cell = cell(1,length(path));    <span class="comment">% Create cell arrays.</span>
Lfd_cell = cell(1,length(path));

nbasis = zeros(length(path),1);

bigknots = knots_cell{1};             <span class="comment">% bigknots used for quadrature points</span>
nbasis(1) = length(knots_cell{1}) + norder - 2;

<span class="keyword">for</span> i = 2:length(path)
    bigknots = [bigknots knots_cell{i}];
    nbasis(i) = length(knots_cell{i}) + norder -2;
<span class="keyword">end</span>

quadvals = MakeQuadPoints(bigknots,nquad);   <span class="comment">% Create simpson's rule</span>
                                             <span class="comment">% quadrature points and values</span>
<span class="keyword">for</span> i = 1:length(path)
    basis_cell{i} = MakeBasis(range,nbasis(i),norder,<span class="keyword">...</span><span class="comment">  % create bases</span>
        knots_cell{i},quadvals,1);                        <span class="comment">% with quadrature</span>
    Lfd_cell{i} = fdPar(basis_cell{i},1,lambda0);         <span class="comment">% pts  attatched</span>
<span class="keyword">end</span>
</pre><h2>Smooth the data<a name="9"></a></h2><pre class="codeinput">DEfd = smoothfd_cell(Ycell,Tcell,Lfd_cell);
coefs = getcellcoefs(DEfd);


figure(1)
devals = eval_fdcell(tfine,DEfd,0);
<span class="keyword">for</span> i = 1:length(path)
    subplot(length(path),1,i);
    plot(Tcell{i},Ycell{i},<span class="string">'b.'</span>);
    hold <span class="string">on</span>;
    plot(tfine,devals{i},<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,2);
    <span class="keyword">if</span> i==1
        ylabel(<span class="string">'\fontsize{13} X'</span>)
        title([<span class="string">'\fontsize{13} Raw data (.), '</span>, <span class="keyword">...</span>
               <span class="string">'and smooth fit (r-)'</span>])
    <span class="keyword">elseif</span> i==2
        ylabel(<span class="string">'\fontsize{13} Y'</span>)
    <span class="keyword">else</span>
        xlabel(<span class="string">'\fontsize{13} t'</span>)
        ylabel(<span class="string">'\fontsize{13} Z'</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="RosslerEx_01.png"> <h2>Re-smoothing with model-based penalty<a name="10"></a></h2><pre class="codeinput"><span class="comment">% Call the Gauss-Newton solver</span>

[newcoefs,resnorm2] = lsqnonlin(@SplineCoefErr,coefs,[],[],lsopts_other,<span class="keyword">...</span>
    basis_cell,Ycell,Tcell,wts,lambda,fn,[],startpars);

tDEfd = Make_fdcell(newcoefs,basis_cell);

<span class="comment">% Plot results along with exact solution</span>

figure(2)
devals = eval_fdcell(tfine,tDEfd,0);
<span class="keyword">for</span> i = 1:length(path)
    subplot(length(path),1,i);
    plot(tfine,devals{i},<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,2);
    hold <span class="string">on</span>;
    plot(Tcell{i},Ycell{i},<span class="string">'b.'</span>);
    plot(plot_time,plot_path(:,i),<span class="string">'c'</span>);
    hold <span class="string">off</span>
    <span class="keyword">if</span> i==1
        ylabel(<span class="string">'\fontsize{13} X'</span>)
        title([<span class="string">'\fontsize{13} Raw data (.), '</span>, <span class="keyword">...</span>
               <span class="string">'exact solution (r-) and true path (g-)'</span>])
    <span class="keyword">elseif</span> i==2
        ylabel(<span class="string">'\fontsize{13} Y'</span>)
    <span class="keyword">else</span>
        xlabel(<span class="string">'\fontsize{13} t'</span>)
        ylabel(<span class="string">'\fontsize{13} Z'</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">
                                         Norm of      First-order 
 Iteration  Func-count     f(x)          step          optimality   CG-iterations
     0          1          394169                     2.79e+004
     1          2           99997             10      1.25e+004           20
     2          3         79828.5             20      5.63e+003          191
     3          4         46155.6             20      2.03e+004          122
     4          5         8186.78             20      7.67e+003           98
     5          6          2428.9        9.65946            457           90
     6          7         2203.72       0.618387           10.3           58
     7          8         2203.72        3.79297           10.3          298
     8          9         2199.64       0.948242           8.41            0
     9         10         2197.91        1.89648           24.3          310
    10         11         2194.57       0.120914           1.05          104
    11         12         2194.27        0.90216           15.5          307
    12         13          2194.2     0.00665249          0.363           39
    13         14         2194.19      0.0787662         0.0724          308
    14         15         2194.19     0.00788232        0.00217          308
    15         16         2194.19     0.00120445       0.000417          305
    16         17         2194.19    0.000156582      1.85e-005          310
    17         18         2194.19   2.32721e-005      3.18e-006          323
    18         19         2194.19   3.24996e-006      3.81e-007          308
Optimization terminated: relative function value
 changing by less than OPTIONS.TolFun.
</pre><img vspace="5" hspace="5" src="RosslerEx_02.png"> <h2>Perform the Profiled Estimation<a name="11"></a></h2><pre class="codeinput">[newpars,newDEfd_cell] = Profile_GausNewt(startpars,lsopts_out,DEfd,fn,<span class="keyword">...</span>
    lambda,Ycell,Tcell,wts,[],lsopts_in);

disp([<span class="string">'New parameter values: '</span>,num2str(newpars')]);
</pre><pre class="codeoutput">
 Iteration       steps    Residual   Improvement   Grad-norm     parameters
     1           1         1595.94      0.258366    1.45e+003     0.22024     0.10805    -0.83679
     2           1         937.855      0.412351          736     -0.11996   -0.025297    -0.60428
     3           1         574.892      0.387014          423     0.065897   -0.088672    -0.78048
     4           1         494.057       0.14061         1.23     0.077089   -0.033005    -0.68246
     5           1         364.881       0.26146         30.8     0.11369   -0.079087     0.54754
     6           1         234.323      0.357809          210     0.14755  0.00091124      2.1928
     7           1         183.119      0.218521         38.2     0.18784    0.097777      2.8046
     8           1         168.605     0.0792593         15.4     0.19623     0.19162      3.0458
     9           1         167.481     0.0066671        0.241     0.20127     0.22129      3.0709
    10           1         167.478  1.49973e-005      0.00159     0.20134     0.22207      3.0691
    11           1         167.478  2.53113e-010     0.000104     0.20134     0.22208      3.0692
New parameter values: 0.20134     0.22208      3.0692
</pre><h2>Plot Smooth with Profile-Estimated Parameters<a name="12"></a></h2><pre class="codeinput">devals = eval_fdcell(tfine,newDEfd_cell,0);
figure(3)
<span class="keyword">for</span> i = 1:length(path)
    subplot(length(path),1,i)
    plot(tfine,devals{i},<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,2);
    hold <span class="string">on</span>;
    plot(Tcell{i},Ycell{i},<span class="string">'b.'</span>);
    plot(plot_time,plot_path(:,i),<span class="string">'c'</span>);
    hold <span class="string">off</span>
    <span class="keyword">if</span> i==1
        ylabel(<span class="string">'\fontsize{13} X'</span>)
        title([<span class="string">'\fontsize{13} Raw data (.), '</span>, <span class="keyword">...</span>
               <span class="string">'profiled solution (r-) and true path (g-)'</span>])
    <span class="keyword">elseif</span> i==2
        ylabel(<span class="string">'\fontsize{13} Y'</span>)
    <span class="keyword">else</span>
        xlabel(<span class="string">'\fontsize{13} t'</span>)
        ylabel(<span class="string">'\fontsize{13} Z'</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="RosslerEx_03.png"> <h2>Comparison with Smooth Using True Parameters<a name="13"></a></h2><pre class="codeinput">coefs = getcellcoefs(DEfd);   <span class="comment">% Starting coefficient estimates</span>

[truecoefs,resnorm4] = lsqnonlin(@SplineCoefErr,coefs,[],[],<span class="keyword">...</span>
    lsopts_other,basis_cell,Ycell,Tcell,wts,lambda,fn,[],pars);

trueDEfd_cell = Make_fdcell(truecoefs,basis_cell);

figure(4)
devals = eval_fdcell(tfine,trueDEfd_cell,0);
<span class="keyword">for</span> i = 1:length(path)
    subplot(length(path),1,i)
    plot(plot_time,plot_path(:,i),<span class="string">'c'</span>)
    plot(tfine,devals{i},<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,2);
    hold <span class="string">on</span>;
    plot(plot_time,plot_path(:,i),<span class="string">'c'</span>);
    plot(Tcell{i},Ycell{i},<span class="string">'b.'</span>);
    hold <span class="string">off</span>;
    <span class="keyword">if</span> i==1
        ylabel(<span class="string">'\fontsize{13} X'</span>)
        title([<span class="string">'\fontsize{13} Raw data (.), '</span>, <span class="keyword">...</span>
               <span class="string">'exact solution (r-) and true path (g-)'</span>])
    <span class="keyword">elseif</span> i==2
        ylabel(<span class="string">'\fontsize{13} Y'</span>)
    <span class="keyword">else</span>
        xlabel(<span class="string">'\fontsize{13} t'</span>)
        ylabel(<span class="string">'\fontsize{13} Z'</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">
                                         Norm of      First-order 
 Iteration  Func-count     f(x)          step          optimality   CG-iterations
     0          1          139787                     1.52e+004
     1          2         4324.36        3.46001       1.3e+003           10
     2          3         405.558        2.58193            162           38
     3          4         196.091        2.80419            224          150
     4          5           180.1        2.50509            566          253
     5          6         170.573      0.0261129             15           13
     6          7         168.846       0.857847           8.97          365
     7          8         168.657       0.464041           16.1          493
     8          9         168.651    0.000702364          0.327           15
     9         10         168.649      0.0279744          0.101          376
    10         11         168.649     0.00890752        0.00462          548
    11         12         168.649    0.000516013       0.000127          448
    12         13         168.649    0.000129249      1.14e-005          573
    13         14         168.649    1.4119e-005       1.5e-005          603
    14         15         168.649   7.91941e-008      2.73e-006           57
Optimization terminated: relative function value
 changing by less than OPTIONS.TolFun.
</pre><img vspace="5" hspace="5" src="RosslerEx_04.png"> <h2>Squared Error Performance<a name="14"></a></h2><pre class="codeinput"><span class="comment">% Squared error for estimated parameters</span>

newpreds = eval_fdcell(Tcell,newDEfd_cell,0);
new_err = cell(length(newpreds));
<span class="keyword">for</span> i = 1:length(path)
    new_err{i} = wts(i)*(newpreds{i} - Ycell{i}).^2;
<span class="keyword">end</span>

new_err = mean(cell2mat(new_err));

<span class="comment">% Squared error for true parameters</span>

truepreds = eval_fdcell(Tcell,trueDEfd_cell,0);
true_err = cell(length(truepreds));
<span class="keyword">for</span> i = 1:length(path)
    true_err{i} = wts(i)*(truepreds{i} - Ycell{i}).^2;
<span class="keyword">end</span>

true_err = mean(cell2mat(true_err));

<span class="comment">% print out a comparsion</span>

disp([<span class="string">'Estimated sqrd error: '</span>,num2str(new_err)])
disp([<span class="string">'True sqrd error:      '</span>,num2str(true_err)]);
</pre><pre class="codeoutput">Estimated sqrd error: 0.13922
True sqrd error:      0.1395
</pre><h2>Calculate Sample Information and Variance-Covariance Matrices<a name="15"></a></h2><pre class="codeinput"><span class="comment">% Hessian of squared error with respect to parameters</span>

d2Jdp2 = make_d2jdp2(newDEfd_cell,fn,Ycell,Tcell,lambda,newpars,[],wts);

<span class="comment">% Second derivatives with respect to parameters and observations</span>

d2JdpdY = make_d2jdpdy(newDEfd_cell,fn,Ycell,Tcell,lambda,newpars,[],wts);

<span class="comment">% Resulting derivative of parameters with respect to observations</span>

dpdY = -d2Jdp2\d2JdpdY;

<span class="comment">% Variance of observations:</span>

S = make_sigma(DEfd,Tcell,Ycell,0);

<span class="comment">% Resulting parameter covariance matrix:</span>

Cov = dpdY*S*dpdY';

<span class="comment">%  Standard errors</span>

StdDev = sqrt(diag(Cov));

<span class="comment">%  Correlations</span>

Corr = Cov./(StdDev*StdDev');

<span class="comment">%  Display these results</span>

disp(<span class="string">'Approximate covariance matrix for parameters:'</span>)
disp(num2str(Cov))

disp(<span class="string">'Approximate standard errors of parameters:'</span>)
disp(num2str(StdDev'))

disp(<span class="string">'Approximate correlation matrix for parameters:'</span>)
disp(num2str(Corr))
</pre><pre class="codeoutput">Approximate covariance matrix for parameters:
1.2131e-005 4.1516e-005    0.000128
4.1516e-005  0.00028311  0.00083986
   0.000128  0.00083986   0.0031182
Approximate standard errors of parameters:
0.003483    0.016826    0.055841
Approximate correlation matrix for parameters:
      1     0.70841     0.65813
0.70841           1     0.89386
0.65813     0.89386           1
</pre><p class="footer"><br>
            Published with MATLAB&reg; 7.1<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Profile Estimation Experiments - the Rossler Equations
%
% This page provides code to run profiled parameter estimation on data
% generated by the Rossler equations. It follows the same format as
% FhNEx.html and has commentary has therefore been kept to a minimum. 
%
% The Rossler equations are given by
%
% $$x = -y-z$$
%
% $$y = x + ay$$
%
% $$z = b + (x-c)z$$

%% RHS Functions         
                          
odefn       = @rossfunode;    % Function for ODE solver 

fn.fn       = @rossfun;       % RHS function
fn.dfdx     = @rossdfdx;      % Derivative wrt inputs
fn.dfdp     = @rossdfdp;      % Derviative wrt parameters

fn.d2fdx2   = @rossd2fdx2;    % Hessian wrt inputs
fn.d2fdxdp  = @rossd2fdxdp;   % Hessian wrt inputs and parameters
fn.d2fdp2   = @rossd2fdp2;    % Hessian wrt parameters.    

fn.d3fdx3   = @rossd3fdx3;    % Third derivative wrt inputs.
fn.d3fdx2dp = @rossd3fdx2dp;  % Third derivative wrt intputs, inputs and pars.
fn.d3fdxdp2 = @rossd3fdxdp2;  % Third derivative wrt inputs, pars and pars. 

%% Various parameters

y0 = [1.13293; -1.74953; 0.02207];       % Initial conditions

pars = [0.2; 0.2; 3];           % Parameters

sigma = 0.5;                    % Noise Level

jitter = 0.2;                                    % Perturbation for starting 
startpars = pars + jitter*randn(length(pars),1); % parameter estimates
disp(['Initial par. values: ',num2str(startpars')])

%% Observation times

tspan = 0:0.05:20;    % Observation times

obs_pts{1} = 1:length(tspan);      % Which components are observed at
obs_pts{2} = 1:length(tspan);      % which observation times.
obs_pts{3} = 1:length(tspan);


tfine = 0:0.05:20;    % Times to plot solutions

%% Create trajectories

odeopts = odeset('RelTol',1e-13);
[full_time,full_path] = ode45(odefn,tspan,y0,odeopts,pars);
[plot_time,plot_path] = ode45(odefn,tfine,y0,odeopts,pars);

%% Set up observations

Tcell = cell(1,size(full_path,2));
path = Tcell;

for i = 1:length(obs_pts)
    Tcell{i} = full_time(obs_pts{i});
    path{i} = full_path(obs_pts{i},i);
end

% add noise

Ycell = path;                
for i = 1:length(path)
    Ycell{i} = path{i} + sigma*randn(size(path{i}));
end

% and set wts

wts = [];

if isempty(wts)                             % estimate wts if not given
    for i = 1:length(Ycell)
        if ~isempty(Ycell{i})
            wts(i) = 1./sqrt(var(Ycell{i}));
        else
            wts(i) = 1;
        end
    end
end

%% Fitting parameters

lambda  = 1e4;   % Smoothing for model-based penalty
lambda  = lambda*wts;

lambda0 = 1;     % Smoothing for 1st-derivative penalty

nknots = 401;    % Number of knots to use.
nquad  = 5;      % No. between-knots quadrature points.
norder = 3;      % Order of B-spline approximation


%% Profiling optimisation control

lsopts_out = optimset('DerivativeCheck','off','Jacobian','on',...
    'Display','iter','MaxIter',1000,'TolFun',1e-8,'TolX',1e-10);

% Other observed optimiation control
lsopts_other = optimset('DerivativeCheck','off','Jacobian','on',...
    'Display','iter','MaxIter',1000,'TolFun',1e-14,'TolX',1e-14,...
    'JacobMult',@SparseJMfun);

% Optimiation control within profiling
lsopts_in = optimset('DerivativeCheck','off','Jacobian','on',...
    'Display','off','MaxIter',1000,'TolFun',1e-14,'TolX',1e-14,...
    'JacobMult',@SparseJMfun);


%% Setting up functional data objects

% set up knots

range = [min(full_time),max(full_time)];  % range of observations

knots_cell = cell(size(path));            % knots for each basis
knots_cell(:) = {linspace(range(1),range(2),nknots)};

% set up bases

basis_cell = cell(1,length(path));    % Create cell arrays.
Lfd_cell = cell(1,length(path));

nbasis = zeros(length(path),1);

bigknots = knots_cell{1};             % bigknots used for quadrature points
nbasis(1) = length(knots_cell{1}) + norder - 2;            

for i = 2:length(path)
    bigknots = [bigknots knots_cell{i}];
    nbasis(i) = length(knots_cell{i}) + norder -2;
end

quadvals = MakeQuadPoints(bigknots,nquad);   % Create simpson's rule
                                             % quadrature points and values
for i = 1:length(path)
    basis_cell{i} = MakeBasis(range,nbasis(i),norder,...  % create bases
        knots_cell{i},quadvals,1);                        % with quadrature
    Lfd_cell{i} = fdPar(basis_cell{i},1,lambda0);         % pts  attatched
end


%% Smooth the data

DEfd = smoothfd_cell(Ycell,Tcell,Lfd_cell);
coefs = getcellcoefs(DEfd);


figure(1)
devals = eval_fdcell(tfine,DEfd,0);
for i = 1:length(path)
    subplot(length(path),1,i);
    plot(Tcell{i},Ycell{i},'b.');
    hold on;
    plot(tfine,devals{i},'r','LineWidth',2);
    if i==1
        ylabel('\fontsize{13} X')
        title(['\fontsize{13} Raw data (.), ', ...
               'and smooth fit (r-)'])
    elseif i==2
        ylabel('\fontsize{13} Y')
    else
        xlabel('\fontsize{13} t')
        ylabel('\fontsize{13} Z')
    end
end

%% Re-smoothing with model-based penalty

% Call the Gauss-Newton solver

[newcoefs,resnorm2] = lsqnonlin(@SplineCoefErr,coefs,[],[],lsopts_other,...
    basis_cell,Ycell,Tcell,wts,lambda,fn,[],startpars);

tDEfd = Make_fdcell(newcoefs,basis_cell);

% Plot results along with exact solution

figure(2)
devals = eval_fdcell(tfine,tDEfd,0);
for i = 1:length(path)
    subplot(length(path),1,i);
    plot(tfine,devals{i},'r','LineWidth',2);
    hold on;
    plot(Tcell{i},Ycell{i},'b.');
    plot(plot_time,plot_path(:,i),'c');
    hold off
    if i==1
        ylabel('\fontsize{13} X')
        title(['\fontsize{13} Raw data (.), ', ...
               'exact solution (r-) and true path (g-)'])
    elseif i==2
        ylabel('\fontsize{13} Y')
    else
        xlabel('\fontsize{13} t')
        ylabel('\fontsize{13} Z')
    end
end



%% Perform the Profiled Estimation

[newpars,newDEfd_cell] = Profile_GausNewt(startpars,lsopts_out,DEfd,fn,...
    lambda,Ycell,Tcell,wts,[],lsopts_in);

disp(['New parameter values: ',num2str(newpars')]);


%% Plot Smooth with Profile-Estimated Parameters

devals = eval_fdcell(tfine,newDEfd_cell,0);
figure(3)
for i = 1:length(path)
    subplot(length(path),1,i)
    plot(tfine,devals{i},'r','LineWidth',2);
    hold on;
    plot(Tcell{i},Ycell{i},'b.');
    plot(plot_time,plot_path(:,i),'c');
    hold off
    if i==1
        ylabel('\fontsize{13} X')
        title(['\fontsize{13} Raw data (.), ', ...
               'profiled solution (r-) and true path (g-)'])
    elseif i==2
        ylabel('\fontsize{13} Y')
    else
        xlabel('\fontsize{13} t')
        ylabel('\fontsize{13} Z')
    end
end


%% Comparison with Smooth Using True Parameters

coefs = getcellcoefs(DEfd);   % Starting coefficient estimates

[truecoefs,resnorm4] = lsqnonlin(@SplineCoefErr,coefs,[],[],...
    lsopts_other,basis_cell,Ycell,Tcell,wts,lambda,fn,[],pars);

trueDEfd_cell = Make_fdcell(truecoefs,basis_cell);

figure(4)
devals = eval_fdcell(tfine,trueDEfd_cell,0);
for i = 1:length(path)
    subplot(length(path),1,i)
    plot(plot_time,plot_path(:,i),'c')
    plot(tfine,devals{i},'r','LineWidth',2);
    hold on;
    plot(plot_time,plot_path(:,i),'c');
    plot(Tcell{i},Ycell{i},'b.');
    hold off;
    if i==1
        ylabel('\fontsize{13} X')
        title(['\fontsize{13} Raw data (.), ', ...
               'exact solution (r-) and true path (g-)'])
    elseif i==2
        ylabel('\fontsize{13} Y')
    else
        xlabel('\fontsize{13} t')
        ylabel('\fontsize{13} Z')
    end
end



%% Squared Error Performance

% Squared error for estimated parameters

newpreds = eval_fdcell(Tcell,newDEfd_cell,0);
new_err = cell(length(newpreds));
for i = 1:length(path)
    new_err{i} = wts(i)*(newpreds{i} - Ycell{i}).^2;
end

new_err = mean(cell2mat(new_err));

% Squared error for true parameters

truepreds = eval_fdcell(Tcell,trueDEfd_cell,0);
true_err = cell(length(truepreds));
for i = 1:length(path)
    true_err{i} = wts(i)*(truepreds{i} - Ycell{i}).^2;
end

true_err = mean(cell2mat(true_err));

% print out a comparsion

disp(['Estimated sqrd error: ',num2str(new_err)])
disp(['True sqrd error:      ',num2str(true_err)]);

%% Calculate Sample Information and Variance-Covariance Matrices

% Hessian of squared error with respect to parameters

d2Jdp2 = make_d2jdp2(newDEfd_cell,fn,Ycell,Tcell,lambda,newpars,[],wts);

% Second derivatives with respect to parameters and observations

d2JdpdY = make_d2jdpdy(newDEfd_cell,fn,Ycell,Tcell,lambda,newpars,[],wts);

% Resulting derivative of parameters with respect to observations

dpdY = -d2Jdp2\d2JdpdY;

% Variance of observations:

S = make_sigma(DEfd,Tcell,Ycell,0);

% Resulting parameter covariance matrix:

Cov = dpdY*S*dpdY';

%  Standard errors

StdDev = sqrt(diag(Cov));

%  Correlations

Corr = Cov./(StdDev*StdDev');

%  Display these results

disp('Approximate covariance matrix for parameters:')
disp(num2str(Cov))

disp('Approximate standard errors of parameters:')
disp(num2str(StdDev'))

disp('Approximate correlation matrix for parameters:')
disp(num2str(Corr))


##### SOURCE END #####
-->
   </body>
</html>